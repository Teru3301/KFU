//  Решение систем нелинейных уравнений
//  Метод Ньютона-Рафсона
//
//  J - якобиан
//  F - вектор значений всех f(x1, x2 ... xn)
//
//  1)  нахождение матрицы якобиана
//      якобиан - матрица каждая строка которой содержит производную m-ной функции делённой на n-ную неизвестную
//      для данной задачи:
//          (f1(x, y) / x)' (f1(x, y) / y)'     =>  1    cos(y-1)
//          (f2(x, y) / x)' (f2(x, y) / y)'     =>  -cos(x+1)   1
//      либо можно использовать численное приближение производных
//      h - малое прерощение
//      тогда якобиан приближенно вычисляется по формуле численного дифференцирования
//          (f1(x + h, y) - f1(x, y)) / h  (f1(x, y + h) - f1(x, y)) / h
//          (f2(x + h, y) - f2(x, y)) / h  (f2(x, y + h) - f2(x, y)) / h
//      плюс такого способа в том что не нужно искать произволные
//
//  2)  вычисляется определитель матрицы якобиана
//
//  3)  значения x и y уточняются следующим образом...
//      новое значение неизвестной (x1) вычисляется как разность её старого значения (x0) и произведения
//      обратной матрицы якобиана и вектора функций системы F
//
//  4)  шаги 1-3 повторяются до тех пор пока не будет достигнута необходимая точность
//
//  так как задача состоит из двух уравнений можно не искать обратную матрицу, а сразу подставлять нужные значения (81 и 82 строки)


#include <iostream>
#include <cmath>
#include <vector>
#include <iomanip>


double f1(double x, double y)
{
    return std::sin(y - 1.0) + x - 1.3;
}

double f2(double x, double y)
{
    return y - std::sin(x + 1.0) - 0.8;
}

std::vector<std::vector<double>> yakobian(double x, double y, double h)
{
    /*return
        {
            { 1, std::cos(y - 1.0) },                      // Частные производные f1 по x и y
            { -std::cos(x + 1.0), 1 }                      // Частные производные f2 по x и y
        }; */
    return
        {
            { (f1(x + h, y) - f1(x, y)) / h,  (f1(x, y + h) - f1(x, y)) / h},
            { (f2(x + h, y) - f2(x, y)) / h,  (f2(x, y + h) - f2(x, y)) / h}
        };
}

int main()
{
    double x = 1.0;                     //  начальное значение
    double y = 1.0;                     //  начальное значение
    double eps = 0.0001;                //  допустимая погрешность
    std::vector<std::vector<double>> J; //  якобиан

    double zero = 0.0000000001;         //  тоже самое что 0
    double prev_x, prev_y;              //  значения x y предыдущих шагов (для проверки погрешности)
    for (int iteration = 0; iteration < 1000; iteration++)
    {
        J = yakobian(x, y, 0.000001);
        double opredelitel = J[0][0] * J[1][1] - J[0][1] * J[1][0];
        if (std::fabs(opredelitel) < zero)
        {
            std::cout << "данную систему решить нельзя." << std::endl;
            break;
        }

        prev_x = x;
        prev_y = y;

        x -= (J[1][1] * f1(x, y) - J[0][1] * f2(x, y)) / opredelitel;
        y -= (-J[1][0] * f1(x, y) + J[0][0] * f2(x, y)) / opredelitel;

        if (std::fabs(prev_x - x) < eps && std::fabs(prev_y - y) < eps)
        {
            std::cout << "Решение достигнуто на итерации " << iteration << std::endl << "x = " << x << "; y = " << y << std::endl;
            break;
        }
    }

    std::cout << std::fixed << std::setprecision(4);
    std::cout << "f1(x) = " << f1(x, y) << std::endl;
    std::cout << "f2(x) = " << f2(x, y) << std::endl;

    return 0;
}
